# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LayerEditor
                                 A QGIS plugin
 TEST
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Avanesyan and Kazmin
        email                : dul4ityx@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from enum import Enum
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QBrush, QColor
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QTableWidgetItem, QPushButton
from qgis.core import (
    QgsMapLayerType,
    QgsProject,
    QgsWkbTypes,
    QgsMarkerSymbol,
    QgsSingleSymbolRenderer,
    QgsLineSymbol,
    QgsFillSymbol,
    QgsPointXY,
    QgsGeometry,
    QgsVectorLayer,
)

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .Layer_editor_dialog import LayerEditorDialog
from .edit_point_dialog import EditPointDialog
from .edit_line_dialog import EditLineDialog
import os.path


class PointStyle(Enum):
    DIAMOND = 0
    DOT = 1
    TRIANGLE = 2


# Стили, используемые в QT
PenStyle = {0: "solid", 1: "no", 2: "dash", 3: "dot", 4: "dash dot", 5: "dash dot dot"}
# Стили, используемые в QT
BrushStyle = {
    0: "solid",
    1: "no",
    2: "horizontal",
    3: "vertical",
    4: "cross",
    5: "f_diagonal",
    6: "b_diagonal",
    7: "diagonal_x",
    8: "dense1",
    9: "dense2",
    10: "dense3",
    11: "dense4",
    12: "dense5",
    13: "dense6",
    14: "dense7",
}


class LayerEditor:
    """QGIS Plugin Implementation."""

    layers = []

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "LayerEditor_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&LayerEditor")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("LayerEditor", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/Layer_editor/icon.png"
        self.add_action(
            icon_path,
            text=self.tr(""),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        if hasattr(self, "selectedLayer") and isinstance(
            self.selectedLayer, QgsVectorLayer
        ):
            self.selectedLayer.selectionChanged.disconnect(
                self._feature_selection_changed
            )
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&LayerEditor"), action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = LayerEditorDialog()

        # show the dialog
        self.dlg.show()
        self.dlg.comboBoxLayers.clear()
        self.dlg.geometryLabel.hide()
        self.dlg.tableWidget.setRowCount(0)
        self.dlg.pushButton_apply.clicked.connect(self.setElementStyle)
        self.layers = []

        # Set layers
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == QgsMapLayerType.VectorLayer:
                self.layers.append(layer)
        self.dlg.comboBoxLayers.addItems(map(lambda layer: layer.name(), self.layers))

        self.updateData()
        self.updateGeometryData()

        # Update shown widgets
        self.updateWidgetsVisibility()

        def chooseLayer():
            self.updateWidgetsVisibility()
            self.updateData()
            self.updateGeometryData()

        self.dlg.comboBoxLayers.currentIndexChanged.connect(chooseLayer)

        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            self.setElementStyle()

    def resetWidgets():
        self.dlg.geometryLabel.setText("Неверный тип геометрии")
        self.dlg.tableWidget.setRowCount(0)
        if hasattr(self, "selectedLayer") and isinstance(
            self.selectedLayer, QgsVectorLayer
        ):
            self.selectedLayer.selectionChanged.disconnect(
                self._feature_selection_changed
            )

    def updateGeometryData(self):
        self.dlg.tableWidget.setRowCount(0)
        index = self.dlg.comboBoxLayers.currentIndex()
        if hasattr(self, "selectedLayer") and isinstance(
            self.selectedLayer, QgsVectorLayer
        ):
            self.selectedLayer.selectionChanged.disconnect(
                self._feature_selection_changed
            )
        self.selectedLayer = self.layers[index]
        self.selectedLayer.selectionChanged.connect(self._feature_selection_changed)
        try:
            geometryType = self.selectedLayer.geometryType()
            if geometryType == QgsWkbTypes.PointGeometry:
                self.dlg.geometryLabel.setText("Тип геометрии: <b>Точки</b>")
            elif geometryType == QgsWkbTypes.LineGeometry:
                self.dlg.geometryLabel.setText("Тип геометрии: <b>Линии</b>")
            elif geometryType == QgsWkbTypes.PolygonGeometry:
                self.dlg.geometryLabel.setText("Тип геометрии: <b>Полигоны</b>")
            else:
                self.resetWidgets()
                return
        except:
            self.resetWidgets()
            return
        self.dlg.tableWidget.setRowCount(self.selectedLayer.featureCount())
        selectedFeatures = self.selectedLayer.selectedFeatureIds()
        row = 0
        print(self.selectedLayer.getFeatures())
        for feature in self.selectedLayer.getFeatures():
            featureId = feature.id()
            editCallback = lambda _, layer=self.selectedLayer, featureId=featureId: self._edit_geometry(
                layer, featureId
            )
            idItem = QTableWidgetItem(str(featureId))
            idItem.setFlags(QtCore.Qt.ItemIsEnabled)
            if featureId in selectedFeatures:
                self._set_table_call_as_selected(idItem)
            self.dlg.tableWidget.setItem(row, 0, idItem)
            editButton = QPushButton("Редактировать")
            editButton.clicked.connect(editCallback)
            if not feature.hasGeometry():
                editButton.setEnabled(False)
            self.dlg.tableWidget.setCellWidget(row, 1, editButton)
            row += 1

    def updateData(self):
        currentLayerIndex = self.dlg.comboBoxLayers.currentIndex()
        currentLayer = self.layers[currentLayerIndex]
        renderer = currentLayer.renderer()

        geometryType = currentLayer.geometryType() + 1

        if geometryType == QgsWkbTypes.Point:
            self.dlg.mColorButtonPen.setColor(
                renderer.symbol().symbolLayer(0).strokeColor()
            )
            self.dlg.mColorButtonBrush.setColor(
                renderer.symbol().symbolLayer(0).fillColor()
            )
            self.dlg.mQgsSpinBox.setValue(int(renderer.symbol().symbolLayer(0).size()))
            # return

        if (
            geometryType == QgsWkbTypes.LineString
            or geometryType == QgsWkbTypes.MultiLineString
        ):
            print("зашли")
            # print(dir(renderer.symbol().symbolLayer(0)))
            # print(dir(renderer.symbol().symbolLayer(0).strokeColor()))

            # print(dir(self.dlg.mColorButtonPen.setColor()))
            print(dir(renderer.symbol().symbolLayer(0)))

            self.dlg.mColorButtonPen.setColor(renderer.symbol().symbolLayer(0).color())

        if geometryType == QgsWkbTypes.Polygon:
            self.dlg.mColorButtonPen.setColor(
                renderer.symbol().symbolLayer(0).strokeColor()
            )
            self.dlg.mColorButtonBrush.setColor(
                renderer.symbol().symbolLayer(0).fillColor()
            )
            # penWidget.show()
            # strokeWidget.show()
            # brushWidget.show()
            # fillWidget.show()
            # return

    def updateWidgetsVisibility(self):
        penWidget = self.dlg.widgetPen
        strokeWidget = self.dlg.widgetStroke
        pointWidget = self.dlg.widgetPoint
        brushWidget = self.dlg.widgetBrush
        fillWidget = self.dlg.widgetFill

        penWidget.hide()
        strokeWidget.hide()
        pointWidget.hide()
        brushWidget.hide()
        fillWidget.hide()

        self.dlg.mQgsSpinBox.setValue(1)

        currentLayerIndex = self.dlg.comboBoxLayers.currentIndex()
        if currentLayerIndex == -1 or currentLayerIndex >= len(self.layers):
            return

        currentLayer = self.layers[currentLayerIndex]
        if currentLayer.type() != QgsMapLayerType.VectorLayer:
            return

        geometryType = currentLayer.geometryType() + 1
        if geometryType == QgsWkbTypes.Point:
            print("point")
            penWidget.show()
            brushWidget.show()
            pointWidget.show()
            return

        if geometryType == QgsWkbTypes.LineString:
            print("line")
            penWidget.show()
            strokeWidget.show()
            return

        if geometryType == QgsWkbTypes.Polygon:
            penWidget.show()
            strokeWidget.show()
            brushWidget.show()
            fillWidget.show()
            return

    def setElementStyle(self):
        currentLayerIndex = self.dlg.comboBoxLayers.currentIndex()
        currentLayer = self.layers[currentLayerIndex]
        geometryType = currentLayer.geometryType() + 1

        # Если точка
        if geometryType == QgsWkbTypes.Point:
            return self.setStyleForPoint()
        # Если линия
        if geometryType == QgsWkbTypes.LineString:
            return self.setStyleForLine()
        # Если полигон
        if geometryType == QgsWkbTypes.Polygon:
            return self.setStyleForPolygon()

    def setStyleForPoint(self):
        currentLayerIndex = self.dlg.comboBoxLayers.currentIndex()
        currentLayer = self.layers[currentLayerIndex]

        penColor = self.dlg.mColorButtonPen.color().getRgb()
        brushColor = self.dlg.mColorButtonBrush.color().getRgb()
        size = self.dlg.mQgsSpinBox.value()

        pointType = self.dlg.comboBoxPoint.currentIndex()
        pointTypes = [pointStyle.value for pointStyle in PointStyle]
        if pointType not in pointTypes:
            return print("Detected unsupported point style")

        symbol = QgsMarkerSymbol.createSimple(
            {
                "name": PointStyle(pointType).name.lower(),
                "outline_color": ",".join([str(x) for x in penColor]),
                "color": ",".join([str(x) for x in brushColor]),
                "size": size,
            }
        )

        renderer = QgsSingleSymbolRenderer(symbol)
        currentLayer.setRenderer(renderer)
        currentLayer.triggerRepaint()

    def setStyleForLine(self):
        penStyle = self.dlg.comboBoxStroke.currentIndex()
        penStyles = PenStyle.keys()
        size = self.dlg.mQgsSpinBox.value()
        if penStyle not in penStyles:
            return print("Detected unsupported pen style")

        penColor = self.dlg.mColorButtonPen.color().getRgb()
        symbol = QgsLineSymbol.createSimple(
            {
                "outline_color": ",".join([str(x) for x in penColor]),
                "line_style": PenStyle[penStyle],
                "width": size,
            }
        )

        currentLayerIndex = self.dlg.comboBoxLayers.currentIndex()
        currentLayer = self.layers[currentLayerIndex]

        renderer = QgsSingleSymbolRenderer(symbol)
        currentLayer.setRenderer(renderer)
        currentLayer.triggerRepaint()

    def setStyleForPolygon(self):
        penStyle = self.dlg.comboBoxStroke.currentIndex()
        penStyles = PenStyle.keys()
        size = self.dlg.mQgsSpinBox.value()
        if penStyle not in penStyles:
            return print("Detected unsupported pen style")

        brushStyle = self.dlg.comboBoxFill.currentIndex()
        brushStyles = BrushStyle.keys()
        if brushStyle not in brushStyles:
            return print("Detected unsupported brush style")

        penColor = self.dlg.mColorButtonPen.color().getRgb()
        brushColor = self.dlg.mColorButtonBrush.color().getRgb()

        symbol = QgsFillSymbol.createSimple(
            {
                "color": ",".join([str(x) for x in brushColor]),
                "style": BrushStyle[brushStyle],
                "outline_color": ",".join([str(x) for x in penColor]),
                "line_style": PenStyle[penStyle],
                "outline_width": size,
            }
        )

        currentLayerIndex = self.dlg.comboBoxLayers.currentIndex()
        currentLayer = self.layers[currentLayerIndex]

        renderer = QgsSingleSymbolRenderer(symbol)
        currentLayer.setRenderer(renderer)
        currentLayer.triggerRepaint()

    def _feature_selection_changed(
        self, selected: list, deselected: list, clearAndSelect: bool
    ):
        if clearAndSelect:
            for i in range(self.dlg.tableWidget.rowCount()):
                text = self.dlg.tableWidget.item(i, 0).text()
                idItem = QTableWidgetItem(text)
                idItem.setFlags(QtCore.Qt.ItemIsEnabled)
                if i in selected:
                    self._set_table_call_as_selected(idItem)
                self.dlg.tableWidget.setItem(i, 0, idItem)
        else:
            for featureIndex in selected:
                idItem = self.dlg.tableWidget.item(featureIndex, 0)
                self._set_table_call_as_selected(idItem)
                self.dlg.tableWidget.setItem(featureIndex, 0, idItem)
            for featureIndex in deselected:
                text = self.dlg.tableWidget.item(featureIndex, 0).text()
                idItem = QTableWidgetItem(text)
                idItem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.dlg.tableWidget.setItem(featureIndex, 0, idItem)

    def _edit_geometry(self, layer, featureId: int):
        geometryType = layer.geometryType()

        if geometryType == QgsWkbTypes.PointGeometry:
            self._edit_point(layer, featureId)
        elif geometryType == QgsWkbTypes.LineGeometry:
            self._edit_line(layer, featureId)
        elif geometryType == QgsWkbTypes.PolygonGeometry:
            self._edit_polygon(layer, featureId)
        else:
            self._show_warning("Ошибка", "Неподдерживаемый тип геометрии")

    def _edit_point(self, layer, featureId: int):
        self._close_edit_dialog()

        layer.select(featureId)
        feature = layer.getFeature(featureId)
        featureGeometry = feature.geometry().asPoint()

        self.editPointsDlg = editDlg = EditPointDialog()
        # editDlg.layerNameLabel.setText(f'"{layer.name()}" #{featureId} (Точка)')
        editDlg.xLineEdit.setText(str(featureGeometry.x()))
        editDlg.yLineEdit.setText(str(featureGeometry.y()))
        # editDlg.pickButton.clicked.connect(self._toggle_edit_point_picker)
        editDlg.show()

        pointsResult = editDlg.exec_()
        layer.deselect(featureId)
        # self._end_point_picker()
        if pointsResult:
            try:
                x = float(editDlg.xLineEdit.text())
                y = float(editDlg.yLineEdit.text())

                layer.startEditing()
                newGeometry = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                layer.changeGeometry(featureId, newGeometry)
                layer.commitChanges()
            except Exception as error:
                print("Error on edit geometry", error)
                self._show_warning("Ошибка", "Введены неверные координаты")

    def _edit_line(self, layer, featureId: int):
        self._close_edit_dialog()

        layer.select(featureId)
        feature = layer.getFeature(featureId)
        featureGeometry = feature.geometry().asMultiPolyline()[0]

        self.editLineDlg = editDlg = EditLineDialog()
        # editDlg.layerNameLabel.setText(f'"{layer.name()}" #{featureId} (Линии)')

        editDlg.coordsTable.setRowCount(len(featureGeometry))
        i = 0
        for point in featureGeometry:
            xItem = QTableWidgetItem(str(point.x()))
            editDlg.coordsTable.setItem(i, 0, xItem)
            yItem = QTableWidgetItem(str(point.y()))
            editDlg.coordsTable.setItem(i, 1, yItem)
            i += 1

        editDlg.show()

        pointsResult = editDlg.exec_()
        layer.deselect(featureId)
        if pointsResult:
            try:
                for i in range(len(featureGeometry)):
                    x = float(editDlg.coordsTable.item(i, 0).text())
                    y = float(editDlg.coordsTable.item(i, 1).text())
                    featureGeometry[i] = QgsPointXY(x, y)
                layer.startEditing()
                newGeometry = QgsGeometry.fromMultiPolylineXY([featureGeometry])
                layer.changeGeometry(featureId, newGeometry)
                layer.commitChanges()
            except Exception as error:
                print("Error on edit geometry", error)
                self._show_warning("Ошибка", "Введены неверные координаты")

    def _edit_polygon(self, layer, featureId: int):
        self._close_edit_dialog()

        layer.select(featureId)
        feature = layer.getFeature(featureId)
        featureGeometry = feature.geometry().asMultiPolygon()[0][0]

        self.editPolygonDlg = editDlg = EditLineDialog()
        # editDlg.layerNameLabel.setText(f'"{layer.name()}" #{featureId} (Полигоны)')

        editDlg.coordsTable.setRowCount(len(featureGeometry))
        i = 0
        for point in featureGeometry:
            xItem = QTableWidgetItem(str(point.x()))
            editDlg.coordsTable.setItem(i, 0, xItem)
            yItem = QTableWidgetItem(str(point.y()))
            editDlg.coordsTable.setItem(i, 1, yItem)
            i += 1

        editDlg.show()

        pointsResult = editDlg.exec_()
        layer.deselect(featureId)
        if pointsResult:
            try:
                for i in range(len(featureGeometry)):
                    x = float(editDlg.coordsTable.item(i, 0).text())
                    y = float(editDlg.coordsTable.item(i, 1).text())
                    featureGeometry[i] = QgsPointXY(x, y)
                layer.startEditing()
                newGeometry = QgsGeometry.fromMultiPolygonXY([[featureGeometry]])
                layer.changeGeometry(featureId, newGeometry)
                layer.commitChanges()
            except Exception as error:
                print("Error on edit geometry", error)
                self._show_warning("Ошибка", "Введены неверные координаты")

    def _close_edit_dialog(self):
        if hasattr(self, "editPointsDlg"):
            self.editPointsDlg.reject()
            del self.editPointsDlg
        if hasattr(self, "editLineDlg"):
            self.editLineDlg.reject()
            del self.editLineDlg
        if hasattr(self, "editPolygonDlg"):
            self.editPolygonDlg.reject()
            del self.editPolygonDlg

    def _show_warning(self, title: str, content: str):
        msgBox = QMessageBox()
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setText(content)
        msgBox.setWindowTitle(title)
        msgBox.exec()

    def _set_table_call_as_selected(self, item: QTableWidgetItem):
        item.setBackground(QBrush(QColor.fromRgb(255, 220, 51)))
        item.setForeground(QBrush(QColor.fromRgb(28, 28, 28)))
        item.setFlags(QtCore.Qt.ItemIsEnabled)
